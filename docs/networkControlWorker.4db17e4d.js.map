{"version":3,"sources":["../node_modules/@turf/helpers/dist/es/index.js","networkControl/networkControlWorker.js"],"names":["earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","unitsFactors","areaFactors","acres","hectares","feature","geom","properties","options","feat","type","id","bbox","geometry","coordinates","_options","point","lineString","polygon","multiPoint","multiLineString","multiPolygon","Error","Array","isArray","length","isNumber","points","featureCollection","map","coords","_i","coordinates_1","ring","j","polygons","lineStrings","features","fc","geometryCollection","geometries","round","num","precision","multiplier","Math","pow","radiansToLength","units","factor","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","PI","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isNaN","isObject","input","constructor","Object","validateBBox","forEach","validateId","indexOf","workerMasterNetwork","workerMasterPointNetwork","workerIds","networkIndex","networkTree","name","netowrkTimeCheck","Date","now","splitMultiLine","array","reduce","i","a","networkBuild","lines","network","string","direction","networkPoints","f","netowrkDirection","push","tempFeatures","p","networkLines","turf","console","warn","self","postMessage","networkSeed","pointInLineVertices","c","d","b","up","Set","geojsonPrecision","t","coordinatePrecision","extrasPrecision","e","index","toFixed","multi","l","poly","obj","g","_featureCollection","addEventListener","data","slice","linestring","line","error","log","featureId","networkFeatureCollection"],"mappings":"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","file":"networkControlWorker.4db17e4d.js","sourceRoot":"..\\src","sourcesContent":["/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","// 2.108 SECONDS WITH 3537 FEATURES\r\n// JavaScript toFixed() is very slow,\r\n\r\n// self.importScripts('./turf.min.js');\r\n\r\nimport * as turf from \"@turf/helpers\"\r\n\r\nvar workerMasterNetwork = {\r\n  type: \"FeatureCollection\",\r\n  features: []\r\n}\r\n\r\nvar workerMasterPointNetwork = {\r\n  type: \"FeatureCollection\",\r\n  features: []\r\n}\r\n\r\nvar workerIds = [];\r\n\r\nvar networkIndex = [];\r\n\r\nvar networkTree = {\r\n  type: \"FeatureCollection\",\r\n  name: \"networkTree\",\r\n  features: []\r\n}\r\n\r\nvar netowrkTimeCheck = Date.now();\r\n\r\nself.addEventListener('message', function(e) {\r\n  // LOG ANY MESSAGES FOR DEBUGGING\r\n  // this.console.log(e)\r\n\r\n  if (e.data.features && e.data.name === \"network\") {\r\n\r\n    workerMasterNetwork.features = (e.data.features).slice();\r\n\r\n    var linestring = turf.featureCollection([]);\r\n    workerMasterNetwork.features.map(feature => {\r\n      if (feature.geometry.coordinates[0][0].length) {\r\n        feature.geometry.coordinates.map(line => {\r\n          linestring.features.push(turf.lineString(geojsonPrecision(line,8)))\r\n        })\r\n      }else{\r\n        linestring.features.push(geojsonPrecision(feature,8))\r\n      }\r\n    })\r\n    workerMasterNetwork.features = (linestring.features).slice();\r\n    // console.log(workerMasterNetwork)\r\n\r\n    var geometryTypeCheck = true;\r\n\r\n    //CHECKING THAT THE CONVERSION WORKED\r\n    workerMasterNetwork.features.reduce((i,f) => {\r\n      if (f.geometry.type != \"LineString\") error = true;\r\n      return [...i, f.geometry.type]\r\n    },[]);\r\n\r\n    if (geometryTypeCheck) {\r\n      console.log(\"all geometries are linestrings, the tool should work\")\r\n    }else{\r\n      console.warn(\"all geometries are not linestrings, the tool may break\");\r\n      alert(\"all geometries are not linestrings, the tool may break\")\r\n    }\r\n\r\n    this.console.log(\"worker added\", workerMasterNetwork.features.length, \"features to the master linear network \")\r\n  }\r\n\r\n  if (e.data.features && e.data.name === \"pointNetwork\") {\r\n    workerMasterPointNetwork.features = (e.data.features).slice()\r\n    this.console.log(\"worker added\", workerMasterPointNetwork.features.length, \"features to the master point network \")\r\n  }\r\n\r\n  if (!e.data.features && e.data.geometry && e.data.geometry.type === \"Point\") {\r\n    console.log(\"received network trace request\", e.data)\r\n    // GRAB CURRENT TIME TO CHECK DURATION OF NETWORK TRACE\r\n    netowrkTimeCheck = Date.now();\r\n\r\n    // RESET NETWORK TREE & WORKER IDS\r\n    networkTree.features = [];\r\n    \r\n    workerIds = new Array(workerMasterNetwork.features.length)\r\n    networkIndex = new Array(workerMasterNetwork.features.length)\r\n\r\n    networkIndex[e.data.properties.index] = {\r\n      up: [e.data.properties.index]\r\n    }\r\n\r\n    var featureId = e.data.properties.index;\r\n    \r\n    //GET SEED FEATURES\r\n    var networkFeatureCollection = networkLines(e.data, workerMasterNetwork, null, featureId)\r\n\r\n    networkTree.features = networkFeatureCollection.features.slice(0);\r\n\r\n    //BUILD NETWORK\r\n    networkBuild(networkFeatureCollection, workerMasterNetwork, e.data.name)\r\n\r\n  }\r\n\r\n}, false);\r\n\r\nfunction splitMultiLine(array) {\r\n  return array.reduce((i,a) => {\r\n    return [...i,...a]\r\n  },[])\r\n}\r\n\r\nfunction networkBuild(lines, network, string) {\r\n  let direction = string;\r\n  // GET ALL UPSTREAM POINTS\r\n  var networkPoints = [];\r\n\r\n  if (direction === \"upstream\" || direction === \"downstream\") {\r\n    // IGNORE LATERALS\r\n    lines.features.map(function (f,i) {\r\n      var coords = (f.geometry.coordinates[0][0].length) ? splitMultiLine(f.geometry.coordinates) : f.geometry.coordinates;\r\n      var netowrkDirection = (direction === \"upstream\") ? 0 : coords.length - 1;\r\n      networkPoints.push(coords[netowrkDirection]);\r\n    });\r\n  }else{\r\n    //INCLUDE LATERALS\r\n    lines.features.map(function (f) {\r\n      var coords = (f.geometry.coordinates[0][0].length) ? splitMultiLine(f.geometry.coordinates) : f.geometry.coordinates;\r\n      for (var i = 0; i < coords.length; i++) {   \r\n        networkPoints.push(f.geometry.coordinates[i]);\r\n      }\r\n    });\r\n  }\r\n \r\n  var tempFeatures = {\r\n    type: \"FeatureCollection\",\r\n    features: []\r\n  };\r\n\r\n  // GET NETWORK LINES FROM THESE POINTS\r\n  for (let p = 0; p < networkPoints.length; p++) {\r\n    var point = turf.point(networkPoints[p]);\r\n    var tempFeatures02 = networkLines(point, network, direction);\r\n    tempFeatures02.features.map(f => {\r\n      tempFeatures.features.push(f);\r\n      networkTree.features.push(f)\r\n    });\r\n  }\r\n  if (tempFeatures.features.length > 0) {\r\n    networkBuild(tempFeatures, network, direction);\r\n  }else{\r\n    console.warn(\"worker network trace took\", Date.now() - netowrkTimeCheck, \"ms\")\r\n    self.postMessage(networkTree);\r\n  }\r\n}\r\n\r\nfunction networkLines(point, network, string, id) {\r\n  var point = point;\r\n  var a = point.geometry.coordinates\r\n  let direction = (!string) ? point.name : string;\r\n  var networkSeed = [];\r\n  for (var i = 0; i < network.features.length; i++) {\r\n\r\n    if (workerIds[i]) {\r\n      continue\r\n    }\r\n\r\n    var f = network.features[i];\r\n\r\n    //TEST REPLACEMENT FOR POINT ON LINE booleanOnLine = 1500s, without = 0.200s\r\n    var pointInLineVertices = false;\r\n    f.geometry.coordinates.map(c => {\r\n      if (a[0] == c[0] && a[1] == c[1]) pointInLineVertices = true\r\n    })\r\n\r\n    if (pointInLineVertices) {\r\n    // if (turf.booleanPointOnLine(point, f)) {\r\n      var d = (direction === \"upstream\" || direction === \"upstream-laterals\") ? 0 : f.geometry.coordinates.length - 1;\r\n      var b = f.geometry.coordinates[d];\r\n      if ( (a[0] != b[0]) || (a[1] != b[1]) ) {\r\n\r\n        workerIds[i] = 1;\r\n        networkSeed.push(f);\r\n        if (!networkIndex[id]) {\r\n          networkIndex[id] = {\r\n            up: [i]\r\n          }\r\n        }else{\r\n          networkIndex[id].up = [i, ...new Set(networkIndex[id].up)]\r\n        }\r\n      }\r\n    }\r\n  };\r\n  \r\n  return turf.featureCollection(networkSeed)\r\n\r\n}\r\n\r\n\r\nfunction geojsonPrecision(t, coordinatePrecision, extrasPrecision) {\r\n\r\n  function point(p) {\r\n    return p.map(function (e, index) {\r\n      if (index < 2) {\r\n        return 1 * e.toFixed(coordinatePrecision);\r\n      } else {\r\n        return 1 * e.toFixed(extrasPrecision);\r\n      }\r\n    });\r\n  }\r\n\r\n  function multi(l) {\r\n    return l.map(point);\r\n  }\r\n\r\n  function poly(p) {\r\n    return p.map(multi);\r\n  }\r\n\r\n  function multiPoly(m) {\r\n    return m.map(poly);\r\n  }\r\n\r\n  function geometry(obj) {\r\n    if (!obj) {\r\n      return {};\r\n    }\r\n\r\n    switch (obj.type) {\r\n      case \"Point\":\r\n        obj.coordinates = point(obj.coordinates);\r\n        return obj;\r\n      case \"LineString\":\r\n      case \"MultiPoint\":\r\n        obj.coordinates = multi(obj.coordinates);\r\n        return obj;\r\n      case \"Polygon\":\r\n      case \"MultiLineString\":\r\n        obj.coordinates = poly(obj.coordinates);\r\n        return obj;\r\n      case \"MultiPolygon\":\r\n        obj.coordinates = multiPoly(obj.coordinates);\r\n        return obj;\r\n      case \"GeometryCollection\":\r\n        obj.geometries = obj.geometries.map(geometry);\r\n        return obj;\r\n      default:\r\n        return {};\r\n    }\r\n  }\r\n\r\n  function feature(obj) {\r\n    obj.geometry = geometry(obj.geometry);\r\n    return obj\r\n  }\r\n\r\n  function _featureCollection(f) {\r\n    f.features = f.features.map(feature);\r\n    return f;\r\n  }\r\n\r\n  function geometryCollection(g) {\r\n    g.geometries = g.geometries.map(geometry);\r\n    return g;\r\n  }\r\n\r\n  if (!t) {\r\n    return t;\r\n  }\r\n\r\n  switch (t.type) {\r\n    case \"Feature\":\r\n      return feature(t);\r\n    case \"GeometryCollection\":\r\n      return geometryCollection(t);\r\n    case \"FeatureCollection\":\r\n      return _featureCollection(t);\r\n    case \"Point\":\r\n    case \"LineString\":\r\n    case \"Polygon\":\r\n    case \"MultiPoint\":\r\n    case \"MultiPolygon\":\r\n    case \"MultiLineString\":\r\n      return geometry(t);\r\n    default:\r\n      return t;\r\n  }\r\n\r\n}"]}